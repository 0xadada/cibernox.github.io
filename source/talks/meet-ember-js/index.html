<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link href='http://fonts.googleapis.com/css?family=Creepster' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">
		<link rel="stylesheet" href="css/theme/my-customizations.css" id="theme-customizations">
		<link rel="stylesheet" href="lib/css/kudos.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"></script>
		<script src="lib/js/jquery-2.1.0.min.js"></script>
		<script src="lib/js/handlebars.js"></script>
		<script src="lib/js/ember-1.4.0.js"></script>
		<script src="lib/js/kudos.js"></script>
		<script>
			$(function(){
			  $("figure.kudo").kudoable();
			});
		</script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Meet Ember.js</h1>
					<h3>Not just another js framework.</h3>
					<img src="images/ember-logo.png" alt="Ember's logo" height="300px" width="300px">
					<p class="text-right bigger-text">Miguel Camba</p>
					<div class="text-right big-text low-height">
						<img src="images/twitter-logo.png" alt="twitter-logo" height="40px" width="48px" class="inline-icon">
						@miguelcamba
					</div>
					<div class="text-right big-text low-height">
						<img src="images/github-logo.png" alt="github-logo" height="52px" width="52px" class="inline-icon">
						@cibernox &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					</div>
				</section>

				<section>
					<img src="images/kerad-logo.png" alt="kerad-logo">
				  <aside class="notes">
						I work on Kerad Games, a games company based here in Barcelona...
					</aside>
				</section>

				<section>
					<img src="images/goldenmanager-logo.png" alt="kerad-logo" width="549px" height="513px">
					<aside class="notes">
						and our first game is "Golden Manager" an online footbal manager where you can
						train, decide your strategy, buy better players, manage your finances and build
						the better team.
					</aside>
				</section>

				<section>
					<img src="images/html-logo.png" alt="kerad-logo" style="width: 186px; height: 255px; max-height: none; max-width: none; position: absolute; z-index: 4; left: 68px; top: 19px;">
					<img src="images/css-logo.png" alt="kerad-logo" style="width: 186px; height: 255px; max-height: none; max-width: none; position: absolute; z-index: 4; left: 707px; top: 22px;">
					<img src="images/js-logo.png" alt="kerad-logo" style="width: 186px; height: 255px; max-height: none; max-width: none; position: absolute; z-index: 4; left: 378px; top: 403px;">
					<img class="fragment" data-fragment="0" src="images/tomster-under-construction.png" alt="kerad-logo" style="width: 286.12856058310507px; height: 321.5406823646365px; max-height: none; max-width: none; position: absolute; z-index: 4; left: 363px; top: 80px;">
					<aside class="notes">
						<p>It is build using just web technologies, html5, css, and javascript, and ember acts as the glue for all of them.</p>

						<p>Right now we have about 1M of registered users, which is a lot of people to handle,
						and as any game we need to build a highly responsive and snappy UI experience, so
						we have moved from a classic web structure to a API + web-client approach that is
						proving itself like a huge success</p>

						<p>In fact our ember app is becoming more and more complex. We are delegating more and
						more work to our clients browser and this is allowing us to scale easier.</p>
					</aside>
				</section>

				<section>
					<h2>What is <img src="images/ember-word-logo.png" alt="ember-word-logo" width="229px" height="87px" class="sub-icon"></h2>
					<br>
					<br>
					<ul class="spaced-list">
						<li>A new MVC framework designed to build ambitious web apps.</li>
						<li>It does a lot of job for you, so you can focus on what really matters.</li>
						<li>Reduces boilerplate code.</li>
						<li>Keeps your views updated with a powerful binding mechanism.</li>
					</ul>
					<aside class="notes">
						<p>Soooo, what is ember?</p>
						<ul>
							<li>new mvc.... : I don't know if any you have used it already, but I'm sure many are familiar to web frameworks and web apps.</li>
							<li>it does a lot...</li>
							<li>reduces boiler.....</li>
							<li>keeps your views......</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2 style="position: absolute;">Oh really?</h2>
					<img src="images/true-story.png" alt="true-story">
					<aside class="notes">
						<p>...Humm, that sounds familiar to me.</p>
						<br>
						<p>Every framework claims more or less the same.</p
						<p>And that is because we all as developers want the same. We want to buil faster apps, with less code</p>
						<p>and focus of our specific business logic without reinvent the wheel.</p>
					</aside>
				</section>

				<section>
					<h2>Options in the wild.</h2>
					<img src="images/knockout-logo.png" class="absolute-element fragment" style="position: absolute; width: 482.50656167979px; height: 157px; z-index: 4; left: 478px; top: 554px; max-height: none; max-width: none;">
					<img src="images/canjs-white-logo.png" class="absolute-element fragment" style="position: absolute; max-height: none; max-width: none; width: 412px; height: 168px; z-index: 4; left: 491px; top: 126px;" data-fragment-index="0">
					<img src="images/angular-logo.png" class="absolute-element fragment" style="position: absolute; max-height: none; max-width: none; width: 305.96237965247553px; height: 306.5762216611604px; z-index: 4; left: 84px; top: 98px;" data-fragment-index="1">
					<img src="images/react-logo.png" class="absolute-element fragment" style="position: absolute; max-height: none; max-width: none; width: 387px; height: 155px; z-index: 4; left: 75px; top: 484px;" data-fragment-index="2">
					<img src="images/backbone-logo-lighter.png" class="absolute-element fragment" style="width: 547px; height: 97px; max-height: none; max-width: none; position: absolute; z-index: 4; left: 360px; top: 362px;">
					<aside class="notes">
						<p>There is a lot of alternatives out there. These are just some of the most popular ones.
						Some of them are sponsored by big corporations, like google or facebook, so, what makes ember interesting?</p>
						<p>If we think about those frameworks, all of them have something in common. The problem they
						try to solve is the same....</p>
					</aside>
				</section>

				<section>
					<h1 class="creepster" style="margin-bottom:0;">User interfaces</h1>
					<h4 class="gray-text text-right"><small><i>(Scary words that deserve a scary font)</i></small></h4>
					<br>
					<h3>User interfaces are hard</h3>
					<br>
					<ul class="spaced-list">
						<li>Display data from a source.</li>
						<li>Keep that information updated when source changes.</li>
						<li>React to user interaction.</li>
						<li>Store contextual state.</li>
					</ul>
					<aside class="notes">
						**BUILD USER INTERFACES**

						They try to provide some foundations and patters to build UI's on a platform (the browser)
						that was not originally designed to it.

						The problem is that UI's **are hard**.
						* They need to react to events
						* show information from a source data
						* keep that information updated when the inner data changes
						* store contextual state (where am it? How I came here? Where i was before? What was my previous action?)

						Although that problem is new to us (web developers), it has been solved for a while
						in desktop and mobile applications, so what ember's team said was:

						Why not pick the solutions that have been there for a while and are battle-tested in desktop/mobile
						apps and bring those patters to the web?

						And that's what they did
					</aside>
				</section>

				<section>
					<h2>A bit of history</h2>
					<img src="images/tomster-release.png" alt="tomster-release" width="356.4px" height="473.4px">
				</section>

				<section>
					<ul class="spaced-list">
						<li class="fragment"><i class="gray-text">2007</i> - SproutCore is released.</li>
						<li class="fragment"><i class="gray-text">2008</i> - Apple announces MobileMe & iWork (built with sproutcore)</li>
						<li class="fragment"><i class="gray-text">2010</i> - SproutCore team leaves Apple and starts Strobe Inc.</li>
						<li class="fragment"><i class="gray-text">2011 (May)</i> - SproutCore 2.0 announced</li>
						<li class="fragment"><i class="gray-text">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Nov)</i> - Apple builds Strobe in a talent adquisition.</li>
						<li class="fragment"><i class="gray-text">2012</i> - Tom Dale (ex-apple) and Yehuda Kats leave Strobe, start Tilde and made a fork of SproutCore that is later renamed to Ember.</li>
						<li class="fragment"><i class="gray-text">7 months ago</i> - 1.5 Years later Ember hits 1.0</li>
					</ul>
					<aside class="notes">
						As you see, it has been a looong way so far. But during that time ember extracted
						knowledge from multiple sources. One that is specially present Apple DNA. Many of the
						design principles and patterns that ember uses are inspired by cocoa's internals and
						the way Mac and iOS app interfaces are built.
					</aside>
				</section>

				<section>
					<h2><img src="images/ember-structure.png" alt="ember-eiffel-tower" style="vertical-align: -75%"> Ember's Architecture</h2>
					<br>
					<ul class="spaced-list">
						<li class="fragment">MVC framework (with Ember's own flavour)</li>
						<li class="fragment">The URL is foundational for Ember</li>
						<li class="fragment">Convention over configuration. Highly opinionated <i class="gray-text">à la rails</i></li>
						<li class="fragment">Enforces simple UI design</li>
					</ul>
					<aside class="notes">
						* MVC framework (with Ember's flavour)
						_Ember is a MVC framework as you would expect. It has its own flavour of MVC that takes many concepts from cocoa and rails._

						* The URL is foundational for Ember.
						_Ember guys don't like very much the term: "Single page application". Even if the browser doesn't reloads the URL's map your resources_

						* Convention over configuration. Highly opinionated _à la rails_.
						_Although some people might argue against this approach, it has proben itself very convenient. Big applications need architecture._
						_In that sense, Ember is quite different to Angular. Angular has been described as a framework to build your one framework_
						_In ember everything has a predefined place and name by convention._
						_There is no route without controller, controller without view or view without template_

						* Enforces simple UI design.
						_Ember relies on Handlebars for its templates. Handlebars is an superset of moustache templating language, and so, it logicless_
						_Remember those angular directives that perform some kind of javascript evaluation? You won't find that here._

						I'll expand this points in reverse order. Lets start by the last one. The templates.
					</aside>
				</section>

				<section data-state="diagram-event">
					<h3>Ember <i>MVC</i></h3>
				  <div class="ember-diagram">
				  	<div class="display-flex">
							<div class="diagram-entity flex-1 yellow-bg fragment roll-in" data-fragment-index="9	">API</div>
				  	</div>
				  	<div class="display-flex">
							<div class="diagram-entity flex-1 green-bg fragment roll-in" data-fragment-index="8">Store</div>
				  	</div>
				  	<div class="display-flex">
					  	<div class="vertical-layer fragment fade" data-fragment-index="1">
					  		<div class="diagram-entity">
					  			<div class="vertical-text">Router</div>
					  		</div>
					  	</div>
					  	<div class="vertical-layer fragment fade" data-fragment-index="2">
					  		<div class="diagram-entity">
					  			<div class="vertical-text">Route</div>
					  		</div>
					  	</div>
					  	<div class="horizontal-layers">
								<div class="diagram-layer flex-container">
									<div class="flex-1 flex-container">
										<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="6">
											<span>Model</span>
										</div>
										<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="6">
											<span>Model</span>
										</div>
									</div>
									<div class="flex-1 flex-container">
										<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="7">
											<span>Model</span>
										</div>
										<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="7">
											<span>Model</span>
										</div>
									</div>
								</div>
								<div class="diagram-layer flex-container">
									<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="3">
										<span>Controller</span>
									</div>
									<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="7">
										<span>Controller</span>
									</div>
								</div>
								<div class="diagram-layer flex-container">
									<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="4">
										<span>View</span>
									</div>
									<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="7">
										<span>View</span>
									</div>
								</div>
								<div class="diagram-layer flex-container">
									<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="5">
										<span>Template</span>
									</div>
									<div class="diagram-entity blue-bg flex-1 fragment roll-in" data-fragment-index="7">
										<span>Template</span>
									</div>
								</div>
					  	</div>
				  	</div>
				  </div>
				  <aside class="notes">
				  	So lets talk about Ember's MVC. For people like me used to backend development,
				  	the MVC approach of ember is quite confusing at first, mainly because its more
				  	similar to Cocoa MVC pattern and the naming has some false friends.

				  	First of all, ember is still a framework created for the web, so there is a layer
				  	for url recognision. It's called "the router". No surprises here, is just what it
				  	looks. A library that listen for changes in the URL and matches them to some actions.

				  	When the router find a URL, it invokes its associated route. "A route" was a brand new
				  	concept for me. It matches a section of your app and it is responsable instantiate
				  	a controller, its view, its template and populate the controllers with the needed
				  	data (The models).

				  	"Models" are also what they seem. They represent your the actors of your business logic.
						"Controllers" on the other hand are a bit different of what I was used. Since is usually
						responsability of the route to find and inject the models into the controllers, the
						responsability of the controllers is only to control the access to that models, decorating
						them with application state and modifing them reacting to user actions.
						"Views" are quite dumb. It responsability is to control the rendering of the section
						and to transform meaningless browser events like "click" or "blur" into business
						related actions like "Publish" or "Validate". They link controllers and templates.
						"Templates" are just templates.

						Another key difference here is that, unlike backend framworks, there is more of all of this.
						In backend, a request arrives, a controllers is instantiated, and html answer is generated and
						sent and we start over again. Here controllers and models are long-lived, so in ocasions
						controllers can interact between them. When you are in a section of the game, your actions
						can have effects in other parts of the game you are not even visualizing right now.

						So far, this is the basic ember structure. However, most of the times you want to have some
						kind of persistence. Ember handles this with "the store". You can think in the store as a
						persistence layer that abstract you from the implementation details of the persistence strategy
						you've chosen, tipically a JSON API, but it could be local storage, an web sockets channel, whatever...
				  </aside>
				</section>

				<section>
					<h2><img src="images/ember-handlebars.png" alt="ember-handlebars" style="vertical-align: -75%"> Handlebars templates</h2>
				</section>

				<section>
					<div class="fragment">
						<blockquote class="wide-quote">Handlebars.js is an extension to the Mustache templating language. Both are logicless templating languages that keep the view and the code separated like we all know they should be.</blockquote>
						<p class="text-right gray-text"><i>Yehuda Katz</i></p>
					</div>
					<br>
					<p class="fragment">Example:</p>
					<pre class="fragment">
<code class="html">&lt;div class=&quot;player-profile&quot;&gt;
  &lt;img alt=&quot;player-image&quot; {{bind-attr src=&quot;imageUrl&quot;}}&gt;
  &lt;p class=&quot;name&quot;&gt;{{name}}&lt;/p&gt;
&lt;/div&gt;</code>
					</pre>
					<p class="fragment"><code class="yellow-text">name</code> and the <code class="yellow-text">src</code> attribute are bound!</p>
					<aside class="notes">
						Handlebars is a text-based template engine.

						That's how a handlebars template looks like.

						You can interpolate expressions into the html with `{{}}` or bind attributes
						with the build-in `bind-attr` helper.

						The cool thing there is that those interpolated stuff is always bound. Whenever the name
						or picture of this player changes, the template will be updated too.
					</aside>
				</section>

				<section>
					<h3>Live example</h3>
					<div id="handlebars-live-example"></div>
					<script>
						(function() {
							var App = Ember.Application.create({
								rootElement: '#handlebars-live-example'
							});
							App.Router.reopen({
							  location: 'none'
							});
							App.Router.map(function() {});
							App.IndexRoute = Ember.Route.extend({
							  model: function() {
							    return { imageUrl: "images/ember-logo.png", name: "Tomster" };
							  }
							});
							Ember.TEMPLATES['index'] = Ember.Handlebars.compile('{{textarea value=text rows="7" class="live-example"}}<br>{{partial tpl}}');
							App.IndexController = Ember.ObjectController.extend({
							  tpl: 'first',
							  text: '<div class="player-profile">\n    <img alt="player-image" {{bind-attr src="imageUrl"}}>\n    <p class="name">Name: {{name}}</p>\n</div>',

							  textDidChange: function() {
							    var text = this.get('text');
							    var hash = CryptoJS.MD5(text);
							    try {
							      var templateName = "tmpl-" + hash;
							      Ember.TEMPLATES[templateName] = Ember.Handlebars.compile(text);
							      this.set('tpl', templateName);
							    } catch(e){ }
							  }.observes('text').on('init')
							});
						})();
					</script>
				</section>

				<section>
					<h3>Convention over configuration</h3>
					<ul class="spaced-list">
						<li>URL: <code class="yellow-text">/messages</code></li>
						<li>Will be routed to the <code class="yellow-text">App.MessagesRoute</code></li>
						<li>that populates the <i>model</i> of the <code class="yellow-text">App.MessagesController</code></li>
						<li>which has a view named <code class="yellow-text">App.MessagesView</code></li>
						<li>and renders a templated named <code class="yellow-text">messages.hbs</code></li>
					</ol>
					<aside class="notes">
						One of the minds behind ember is Yehuda Katz. Yehuda is part of Ruby on Rails,
						and one of its footprints in ember's design is the omnipresence of the "convention
						over configuration" mantra.

						Tipically in ember a given section of your all will have this elements:
						[route, controller, view and template]
						That structure is always the same. But you should not be afraid of all this elements
						interacting between them, because the good part is...
					</aside>
				</section>

				<section>
					<h3>You don't have to write them!</h3>
					<br>
					<p>If any of these elements is not defined, ember creates it for us.</p>
					<br>
					<p>Those anonymous elements have many default behaviors built in.</p>
					<br>
					<p>You only need to write what makes your app special.</p>
					<aside class="notes">
						And even if you want any custom behavior, most of the time 90% of the
						default behavior is just fine.
						Lets take a look into an example with the routes.
					</aside>
				</section>

				<section>
					<h3>The router</h3>
					<br>
					<p>Foundational URL: Each unique resource has a uniq identifier.</p>
					<br>
					<p>The router links that URL with the state hander reponsable of that section.</p>
					<pre>
<code data-trim class="javascript no-limits">App.Router.map(function(){
  this.resource('posts', function() {
    // Url: NA              Route name: "posts"          Route: App.PostsRoute
    // and also..
    // Url: "/posts"        Route name: "posts.index"    Route: App.PostsIndexRoute

    this.route('new');
    // Url: "/posts/new"    Route name: "posts.new"      Route: App.PostsNewRoute
  });

  this.route('about');
  // Url: "/about"          Route name: "about"          Route: App.AboutRoute

});</code>
					</pre>
					<aside class="notes">
						I say "the router" because in this case there is only one. The router is
						the piece of software that determines which route must be invoked when the application
						transitions between urls.

						As I've said before, the URL is foundational for ember. The answer for questions
						like "is the user logged in?" or "which match is the user playing?" should have
						a unique representation in the system, and the URL is just designed for that.

						The router is the manifest that links url with the state handlers of the application:
						the routes.
					</aside>
				</section>

				<section>
					<h3>Routes</h3>
					<br>
					<p>Populate and setup the controllers of the current section of the application</p><br>
					<p>Manage the transition between the different routes (the top-level state)</p><br>
					<p>Fortunatelly, 99% percent of the time, ember does all the hard work for you</p><br>
					<aside class="notes">
						First of all... ¿What is a route?
						Routes as are understood by ember were quite a new concept for me when I first
						meet ember. And controllers too. Probably because I am also a Rails developer and
						that made me fall into the trap of identify those elements with Rails' homonims, but
						their roles are quite different to what backend developers are used to.

						Routes are not the matching between the url and the controllers. Those matchings
						are specified in the <i>Router</i>.

						The routes are the objects what are responsable of, on the one hand,
						populate and prepare the models of the controllers (usually talking
						with and external API) and on the other hand, manage the state transition
						that your application suffers.
					</aside>
				</section>

				<section>
					<h3>Route's full behavior</h3>
					<pre>
<code data-trim class="javascript no-limits">App.MessagesRoute = Ember.Router.extend({
  activate: function(){
    /* Hook called when entering the route. */
  },
  redirect: function(){
    /* Hook for redirect to another route right away. */
  },
  beforeModel: function(transition){
    /* Hook usefull to perform any async operation needed before loading the model. */
  },
  model: function(params, transition){
    /* Hook to fetch/build the content of the route's controller. */
  },
  afterModel: function(resolvedModel, transition){
    /* Hook to perform any operation with the model before it is injected in the controller. */
  },
  setupController: function(controller, model){
    /* By default, injected the given model in the given controller. */
  },
  renderTemplate: function(controller, model){
    /* By default renders the route's template with the route's controller as context. */
  },
  deactivate: function(){
    /* Hook for perform any teardown if needed. */
  }
});</code>
					</pre>
					<aside class="notes">
						TODO:
					</aside>
				</section>

				<section>
					<h3>Average route code</h3>
					<p>95% of the time, the average route has 5 lines that look like this:</p>
					<pre class="fragment">
<code data-trim class="javascript no-limits">App.MessagesRoute = Ember.Router.extend({
  model: function(params, transition){
    return this.get('store').find('message');
  }
});</code>
					</pre>
					<p class="fragment">The rest of the default behavior is just fine.</p>
					<aside class="notes">
						But most of the time you don't need any of this flexibility. 95% of the
						time the route only populates the content of a controller with some data
						and that only takes a few lines of code.
					</aside>
				</section>

				<section>
					<h3>Controllers</h3>
					<br>
					<p class="fragment">Expose and decorate the underlying data with contextual information.</p>
					<br>
					<p class="fragment">React to user actions modifying data and store contextual state.</p>
					<br>
					<p class="fragment">You can extend 3 kinds of controllers depending on your needs:
					<p class="fragment"><code class="yellow-text">Ember.Controller</code></p>
					<p class="fragment"><code class="yellow-text">Ember.ObjectController</code></p>
					<p class="fragment"><code class="yellow-text">Ember.ArrayController</code></p>
					<aside class="notes">
						The next item in the ember's toolchaing are the controllers.

						Again, controllers are a bit different to what backend developers are used to.

						They are responsable of expose and decorate the underlaying data, ofter
						with information that is dependent of the application state.

						By example, in out game, a played match is the same for you and for your rival,
						but depending of you being the manager of the home team or the away team, you will
						see the same goal as a success or a failure.

						Also, controllers have the responsability of modify the data reacting to user
						actions and store contextual state that does not need to be persisted in the
						backend.
					</aside>
				</section>

				<section>
					<h4>Decorate models depending on application state</h4>
					<pre>
<code class="javascript">App.QuestionController = Ember.ObjectController.extend({
  needs: ['currentUser'],

  own: function(){ /* Application state. Depends on the current user being logged */
    return this.get('creator.id') == this.get('controllers.currentUser.id');
  }.property('creator.id', 'controllers.currentUser')
});</code>
					</pre>
					<pre>
<code class="html">{{#if own}}&lt;button {{action markAsSolved}}&gt;Mark as solved&lt;/button&gt;{{/if}}
{{#unless own}}
  &lt;textarea class=&quot;answer&quot;&gt;&lt;/textarea&gt;
  &lt;button {{action sendAnswer}}&gt;&lt;/button&gt;
{{/unless}}
{{#link-to lastSeenQuestion}}Back to last seen question.{{/link-to}}
</code>
					</pre>
					<aside class="notes">
						I would like to clarify what application state means, because is a concept
						that can be tricky.
						If a user asks a question on stack overflow, buys a player on goldenmanager
						or starts a conversation on discourse, that is business state, the probably
						needs to be persisted.

						When a player browses your application, starts writting a post or reads a
						question, there is another kind of state that only belongs to the application life:
						<i>Was that question asked by me?</i><i>What was the last section I visited?</i>
						<i>Is the post body long enough to be publised?</i>. Although this state is long
						lived, its realm is the application itself.

						Lets see that example.

						Let's say I am reading a question. All question in stackoverflow have a user that
						created that question. But depending on if the question is mine or not, I can do different
						things and see different buttons.

						When I am the question's creator I can see a button to mark the question as solved. When I am not,
						I see a textarea to place an answer. And In both cases, I have a link to go read again the last question
						I've visited, which depends on what page has the user visited just before.
					</aside>
				</section>

				<section>
					<h3>The Views</h3>
					<br>
					<p class="fragment">Handle view state/rendering and transform browser meaningless avents into
					business-logic related events.</p>
					<br>
					<div class="fragment">
						<div class="kudos-container">
					    <figure class="kudo kudoable" data-id="1">
					        <a class="kudobject">
					            <div class="opening">
					                <div class="circle">&nbsp;</div>
					            </div>
					        </a>
					        <a href="#kudo" class="count">
					            <span class="num">0</span>
					            <span class="txt">Kudos</span>
					        </a>
					    </figure>
						</div>
						<br>
						<div class="text-right">
						  <a href="https://github.com/masukomi/kudos">
						  	<i class="gray-text">https://github.com/masukomi/kudos</i>
						  </a>
						</div>
					</div>
					<aside class="notes">
						The views in ember most of the time are very dumb, but hey can be very usefull to
						create rich interaction and widgets.

						Lets take as an example the Kudos like button. I've seen over the web in a couple of
						blogs. Its sort of a like button that reacts to hover it for a while.
						That's how it works.
						--- DEMO ---
						If we realize here, there is something we would call view state. The actions we try to
						capture here is a discrete action. To "like" something. But, in order to perform this action,
						we need to interact with the widget for a while. If we stop the action before its completed,
						we need to start over.

						All this kind of state belongs to that very specific part of the UI. It is not something
						we want to store of share across the app.

						However, once we have performed the action, we cannot perform it again. THAT is something we
						want to store and share across the app, maybe forever or maybe for some time.

						Lets see how ember's views would help us to do this.
					</aside>
				</section>


				<section>
					<p>View</p>
					<pre>
<code class="javascript">App.KudosView = Ember.View.extend({
  mouseleaveAt: null,

  // Capture browser generic events
  mouseenter: function(){
    this.set('mouseleaveAt', null);
    Ember.run.later(function(){
      // Send a meaningful event to the controller
      if (!this.get('mouseleaveAt')) this.get('controller').send('like');
    }, 1000);
  },

  mouseleave: function(){
    this.set('mouseleaveAt', new Date());
  }
});
</code>
					</pre>
					<p>Controller</p>
					<pre>
<code class="javascript">App.PostController = Ember.ObjectController.extend({
  actions: {
    like: function(){
      this.set('liked', true);
      // Persist the like forever if needed.
    }
  }
});
</code>
					</pre>
					<aside class="notes">

					</aside>
				</section>


				<section>
					<h2>Ember basics: Design choices</h2>
				</section>

				<section>
					<h3>UAP: Uniform access principle</h3>
					<br>
					<div class="fragment">
						<blockquote>
							“All services offered by a module should be available through a uniform notation,
							which does not betray whether they are implemented through storage or through computation”
						</blockquote>
						<p class="text-right gray-text"><i>Bertrand Meyer</i></p>
					</div>
					<br>
					<aside class="notes">
						TOOD
					</aside>
				</section>

				<section>
					Template:
					<pre>
<code class="html"><div class="name">{{user.name}}</div>
<div class="location">{{user.aproximateLocation}}</div></code>
					</pre>
					Somewhere in the app:
					<pre>
<code class="javascript">App.User = Ember.Object.extend({
  aproximateLocation: function(){
    return someExpensiveCalculation();
  }.property()
});

var user = App.User.create({name: "Wilson"});</code>
					</pre>
					<p>Generated HTML:</p>
					<pre>
<code class="html"><div class="name">Wilson</div>
<div class="location">BCN, Spain</div></code>
					</pre>
					<p class="fragment">No matter if <code class="yellow-text">name</code> or <code class="yellow-text">aproximateLocation</code>
					are a properties that are just read or function that perform complex calculations, they are  accessed in the same way.</p>
					<br>
					<aside class="notes">
						TODO
					</aside>
				</section>

				<section data-background="images/all-the-things-alpha.png">
					<h3><span class="fragment">State.</span> <span class="fragment">Machine.</span> <span class="fragment">All.</span> <span class="fragment">The.</span> <span class="fragment">Things.</span></h3>
					<br>
					<p class="fragment">Express your business logic declaratively.</p>
					<br>
					<p class="fragment">Define dependencies and calculations between properties.</p>
					<br>
					<p class="fragment">React to user actions modifying some value in your underlying data.</p>
					<br>
					<p class="fragment">All properties that had dependencies on it gets recomputed automatically.</p>
				</section>

				<section>
					<h3>Example.</h3>
					<br>
					<p>StackOverflows questions:</p>
					<br>
					<ul class="spaced-list">
						<li class="fragment">A question is answered if has at least one answer.</li>
						<li class="fragment">A question is popular if has more than 5 answers.</li>
						<li class="fragment">A question is solved if any answer has been accepted.</li>
						<li class="fragment">A question is hot if its popular but still not solved.</li>
					</ul>
					<br>
					<br>
					<p class="fragment gray-text"><i>How do we express that business logic?</i></p>
					<aside class="notes">
						TODO
					</aside>
				</section>

				<section>
					<h3>Computed properties to the rescue.</h3>
					<pre>
<code class="javascript">App.Question = Ember.Object.extend({
  solutions: [],
  answered: function(){
    return this.get('answers.length') > 0;
  }.property('answers.length'),

  popular: function(){
    return this.get('answers.length') > 5;
  }.property('answers.length'),

  solved: function(){
    return this.get('answers').some(function(answer){
      return answer.get('accepted');
    });
  }.property('answers.@each.accepted'),

  hot: function(){
    return this.get('popular') && !this.get('solved');
  }.property('popular', 'solved')
});</code>
					</pre>
				</section>

				<section>
					<h3>Computed properties to the rescue.</h3>
					<pre>
<code class="javascript">question.get('answers')  // => []
question.get('answered') // => false
question.get('hot')      // => false

question.get('answers').pushObject(Answer.create())

question.get('answers')  // => [Answer]
question.get('answered') // => true
question.get('hot')      // => false

question.get('answers').pushObjects([Answer.create(), Answer.create(), Answer.create(), Answer.create(), Answer.create()])

question.get('answers')  // => [Answer, Answer, Answer, Answer, Answer, Answer]
question.get('answered') // => true
question.get('hot')      // => true

question.get('answers.lastObject').set('accepted', true)

question.get('hot')      // => false
question.get('solved')   // => true</code>
					</pre>
				</section>

				<section>
					<pre class="no-margin">
<code class="html">&lt;article {{bind-attr class=&quot;:question answered hot solved&quot;}}&gt;
  &lt;div class=&quot;excerpt&quot;&gt;{{excerpt text}}&lt;/div&gt;&lt;span class=&quot;answers-counter&quot;&gt;{{answers.length}}&lt;/span&gt;
&lt;/article&gt;</code>
					</pre>
					<p>When it receives 6 answers the html will look like this:</p>
					<pre class="no-margin">
<code class="html"><article class="question answered hot">
  <div class="excerpt">Lorem ipsum dolor sit a...</div><span class="answers">6</span>
</article></code>
					</pre>
					<i class="gray-text">question.get('answers.firstObject').set("accepted", true);</i>
					<pre class="no-margin">
<code class="html"><article class="question answered solved">
  <div class="excerpt">Lorem ipsum dolor sit a...</div><span class="answers">6</span>
</article></code>
					</pre>
				</section>

				<section>
					<h3>And much much more...</h3>
					<ul class="spaced-list">
						<li class="fragment">Extensive use of promises.</li>
						<li class="fragment">Properties observers.</li>
						<li class="fragment">The Run loop.</li>
						<li class="fragment">Isolated components.</li>
						<li class="fragment">Testing tools.</li>
						<li class="fragment">Ember extension for chrome and firefox.</li>
					</ul>
				</section>

				<section>
					<h3>Bonus points: Ember data</h3>
					<br>
					<div class="fragment">
						<p class="small-paragraph"><i>Disclaimer. Still rolling. Not stable yet.</i></p>
						<img src="images/tomster-running.png" alt="running-tomster">
					</div>
				</section>

				<section>
					<p>Ember's <i>"official"</i> persistence layer.</p>
					<p>TODO: Explain what is ember data </p>
				</section>

				<section>
					<h1>Thanks</h1>
					<img src="images/tomster-love.png" alt="thanks">
				</section>



				<section>
					<h1>Q & A</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
